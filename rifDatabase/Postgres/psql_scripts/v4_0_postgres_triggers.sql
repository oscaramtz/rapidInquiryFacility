
-- ************************************************************************
--
-- GIT Header
--
-- $Format:Git ID: (%h) %ci$
-- Version hash: $Format:%H$
--
-- Description:
--
-- Rapid Enquiry Facility (RIF) - Postgres triggers
--
-- Trigger code will be split up on a per table basis
--
-- This is currently run only when the database is built from scripts
-- Ideally it should be refactored into many bits so it can be run easily in
-- alter scripts
--
-- Copyright:
--
-- The Rapid Inquiry Facility (RIF) is an automated tool devised by SAHSU 
-- that rapidly addresses epidemiological and public health questions using 
-- routinely collected health and population data and generates standardised 
-- rates and relative risks for any given health outcome, for specified age 
-- and year ranges, for any given geographical area.
--
-- Copyright 2014 Imperial College London, developed by the Small Area
-- Health Statistics Unit. The work of the Small Area Health Statistics Unit 
-- is funded by the Public Health England as part of the MRC-PHE Centre for 
-- Environment and Health. Funding for this project has also been received 
-- from the Centers for Disease Control and Prevention.  
--
-- This file is part of the Rapid Inquiry Facility (RIF) project.
-- RIF is free software: you can redistribute it and/or modify
-- it under the terms of the GNU Lesser General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- RIF is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
-- GNU Lesser General Public License for more details.
--
-- You should have received a copy of the GNU Lesser General Public License
-- along with RIF. If not, see <http://www.gnu.org/licenses/>; or write 
-- to the Free Software Foundation, Inc., 51 Franklin Street, Fifth Floor, 
-- Boston, MA 02110-1301 USA
--
-- Author:
--
-- Peter Hambly, SAHSU
--
\set ECHO all
\set ON_ERROR_STOP ON
\timing

--
-- Check user is rif40
--
DO LANGUAGE plpgsql $$
BEGIN
	IF user = 'rif40' THEN
		RAISE INFO 'User check: %', user;	
	ELSE
		RAISE EXCEPTION 'C20900: User check failed: % is not rif40', user;	
	END IF;
END;
$$;

-- Generated by Ora2Pg, the Oracle database Schema converter, version 8.13
-- Copyright 2000-2012 Gilles DAROLD. All rights reserved.
-- DATASOURCE: dbi:Oracle:eph1d

\set ON_ERROR_STOP ON
\echo  Creating TABLE triggers 

\set VERBOSITY terse
DO LANGUAGE plpgsql $$
BEGIN
	PERFORM rif40_log_pkg.rif40_add_to_debug('rif40_ddl:DEBUG1'); /* SQL statements - timing DEBUG4 */
	PERFORM rif40_log_pkg.rif40_add_to_debug('rif40_drop_table_triggers:DEBUG1'); /* SQL statements - timing DEBUG4 */
        PERFORM rif40_log_pkg.rif40_log_setup();
        PERFORM rif40_log_pkg.rif40_send_debug_to_info(TRUE);
	PERFORM rif40_trg_pkg.rif40_drop_table_triggers();
END;
$$;
\set VERBOSITY default

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_covariates_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_covariates_checks_description>
<para>
Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type
</para>
</trigger_rif40_covariates_checks_description>
 */
--
-- Error range:  -20140 to -20159 - RIF40_COVARIATES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1tcov CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2tcov CURSOR (l_geolevel_name VARCHAR) IS
		SELECT covariate_table
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel_name;
	c1tcov_rec RECORD;
	c2tcov_rec RECORD;
--
	schema 		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
-- Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists
--
	OPEN c2tcov(NEW.geolevel_name);
	FETCH c2tcov INTO c2tcov_rec;
	CLOSE c2tcov;
	IF (c2tcov_rec.covariate_table IS NOT NULL AND c2tcov_rec.covariate_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(c2tcov_rec.covariate_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20140, 'trigger_fct_rif40_covariates_checks', 
				'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20140] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found for geolevel_name: %, covariate: %',
				LOWER(c2tcov_rec.covariate_table)::VARCHAR	/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.covariate_name::VARCHAR		/* Covariate name */);
		END IF;
		OPEN c1tcov(schema, c2tcov_rec.covariate_table, NEW.covariate_name);
		FETCH c1tcov INTO c1tcov_rec;
		CLOSE c1tcov;
		IF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND coalesce(c1tcov_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20141, 
				'trigger_fct_rif40_covariates_checks', 'Error: RIF40_COVARIATES % column not found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') AND (c1tcov_rec.column_name IS NOT NULL AND c1tcov_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
				'[20141] RIF40_COVARIATES % column found in: % for geolevel_name: %',
				NEW.covariate_name::VARCHAR		/* Covariate name */,
				UPPER(c2tcov_rec.covariate_table)::VARCHAR		/* Covariate table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- 	Check - min < max, max/min precison is appropriate to type
--
	IF NEW.min >= NEW.max THEN
		PERFORM rif40_log_pkg.rif40_error(-20142, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES min >= max: % >= % for geolevel_name: % covariate: %',
			NEW.min::VARCHAR		/* New min */,
			NEW.max::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.max) != NEW.max THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20143, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and max is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			NEW.max::VARCHAR		/* New max */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND ROUND(NEW.min) != NEW.min THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20144, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min is not an integer: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			NEW.min::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR	/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSIF NEW.type = 1 AND NEW.min < 0 THEN /* integer score */
		PERFORM rif40_log_pkg.rif40_error(-20145, 'trigger_fct_rif40_covariates_checks', 
			'Error: RIF40_COVARIATES type = 1 (integer score) and min <0: % for geolevel_name: % covariate: % for geolevel_name: % covariate: %',
			NEW.min::VARCHAR		/* New min */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_covariates_checks', 
			'[20142-5] RIF40_COVARIATES Checked OK for geolevel_name: % covariate: %',
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.covariate_name::VARCHAR		/* Covariate name */);
	END IF;
--
-- Check covariate_name
--
	PERFORM rif40_trg_pkg.rif40_db_name_check('COVARIATE_NAME', NEW.covariate_name);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_covariates_checks() IS 'Check <T_RIF40_GEOLEVELS.COVARIATE_TABLE>.<COVARIATE_NAME> column exists.
Check - min < max, max/min precison is appropriate to type.
Error range:  -20140 to -20159 - RIF40_COVARIATES';

CREATE TRIGGER rif40_covariates_checks
	BEFORE INSERT OR UPDATE OF covariate_name, max, min, type ON rif40_covariates
	FOR EACH ROW
	WHEN ((NEW.covariate_name IS NOT NULL AND NEW.covariate_name::text <> '') OR (NEW.max IS NOT NULL AND NEW.max::text <> '') OR (NEW.min IS NOT NULL AND NEW.min::text <> '') OR (NEW.type IS NOT NULL AND NEW.type::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_covariates_checks();
COMMENT ON TRIGGER rif40_covariates_checks ON rif40_covariates IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()';

CREATE TRIGGER rif40_covariates_checks_del
	BEFORE DELETE ON rif40_covariates
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_covariates_checks();
COMMENT ON TRIGGER rif40_covariates_checks_del ON rif40_covariates IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_covariates_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_error_messages_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_error_messages_checks>
<para>
Check - table_name exists.
</para>
</trigger_rif40_error_messages_checks>
 */
--
-- -20480 to -20499 - RIF40_ERROR_MESSAGES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	schema	VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.table_name::VARCHAR);
--
-- Check HIERARCHYTABLE
--
	IF (NEW.table_name IS NOT NULL AND NEW.table_name::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- This really should be an error - wait until auto generated on PostGres
--
		PERFORM rif40_log_pkg.rif40_log('WARNING', 'trigger_fct_rif40_error_messages_checks', '[20480] RIF40_ERROR_MESSAGES table_name (%) not found',
			LOWER(NEW.table_name)::VARCHAR /* table_name referenced in RIF40_ERROR_MESSAGES */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_error_messages_checks() IS 'Check - table_name exists.
-20480 to -20499 - RIF40_ERROR_MESSAGES';

CREATE TRIGGER rif40_error_messages_checks
	BEFORE INSERT OR UPDATE OF table_name
	ON rif40_error_messages
	FOR EACH ROW
	WHEN ((NEW.table_name IS NOT NULL AND NEW.table_name::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_error_messages_checks();
COMMENT ON TRIGGER rif40_error_messages_checks ON rif40_error_messages IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()';
CREATE TRIGGER rif40_error_messages_checks_del
	BEFORE DELETE ON rif40_error_messages
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_error_messages_checks();
COMMENT ON TRIGGER rif40_error_messages_checks_del ON rif40_error_messages IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_error_messages_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_geog_hierarchytable_description>
<para>
Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
</para>
</trigger_rif40_geog_hierarchytable_description>
 */
--
-- Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1geog CURSOR (l_schema VARCHAR, l_table VARCHAR, l_column VARCHAR) FOR
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2geog CURSOR (l_geolevel VARCHAR) FOR
		SELECT *
		  FROM t_rif40_geolevels
		 WHERE geolevel_name = l_geolevel;
	c3geog CURSOR (l_geography VARCHAR) FOR
		SELECT COUNT(geolevel_name) AS total_geolevels
		  FROM t_rif40_geolevels
		 WHERE l_geography = geography;
--
	c1geog_rec 	RECORD;
	c2ageog_rec 	RECORD;
	c2bgeog_rec 	RECORD;
	c3geog_rec 	RECORD;
--
	schema		VARCHAR;
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
-- Check HIERARCHYTABLE
--
	schema:=rif40_sql_pkg.rif40_object_resolve(NEW.hierarchytable::VARCHAR);
	IF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
--
-- A date_built column needs to be added so the HIERARCHYTABLE can be NULL when trhe RIF builds the hierarchy table
--
--		PERFORM rif40_log_pkg.rif40_error(-20100, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found',
--			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
		NULL;
	ELSIF (NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') AND coalesce(schema::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20100] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found',
			LOWER(NEW.hierarchytable)::VARCHAR /* hierarchy table */);
	END IF;
--
-- Check postal_population_table and postal_point_column
--
	IF (NEW.postal_population_table IS NOT NULL AND NEW.postal_population_table::text <> '') THEN
		schema:=rif40_sql_pkg.rif40_object_resolve(NEW.postal_population_table::VARCHAR);
		IF coalesce(schema::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20101, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found',
				LOWER(NEW.postal_population_table)::VARCHAR /* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20101] RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		OPEN c1geog(schema, NEW.postal_population_table, NEW.postal_point_column);
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20102, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20102] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN column (%.%) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */,
				NEW.postal_point_column::VARCHAR	/* postal point column */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'MALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20103, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.MALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20103] RIF40_GEOGRAPHIES column (%.MALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'FEMALES');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20104, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.FEMALES) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20104] RIF40_GEOGRAPHIES column (%.FEMALES) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'TOTAL');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20105, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.TOTAL) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20105] RIF40_GEOGRAPHIES column (%.TOTAL) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'XCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20106, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.XCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20106] RIF40_GEOGRAPHIES column (%.XCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
		c1geog_rec.column_name:=NULL;
		OPEN c1geog(schema, NEW.postal_population_table, 'YCOORDINATE');
		FETCH c1geog INTO c1geog_rec;
		CLOSE c1geog;
		IF coalesce(c1geog_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20107, 'trigger_fct_rif40_geog_hierarchytable', 'Error: RIF40_GEOGRAPHIES column (%.YCOORDINATE) not found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_geog_hierarchytable', '[20107] RIF40_GEOGRAPHIES column (%.YCOORDINATE) found',
				NEW.postal_population_table::VARCHAR	/* postal population table */);
		END IF;
	END IF;
--
--  Also check defaultcomparea, defaultstudyarea as FK is now removed
--
	OPEN c3geog(NEW.geography);
	FETCH c3geog INTO c3geog_rec;
	CLOSE c3geog;
--
	IF (c3geog_rec.total_geolevels > 0 AND NEW.defaultcomparea IS NOT NULL AND NEW.defaultcomparea::text <> '') THEN
		OPEN c2geog(NEW.defaultcomparea);
		FETCH c2geog INTO c2ageog_rec;
		CLOSE c2geog;
		IF c2ageog_rec.geolevel_name IS NULL THEN
			PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
				'Error: Default comparision area column % not found in T_RIF40_GEOLEVELS for geography: %',
				NEW.defaultcomparea::VARCHAR	/* Default comparision area */,
				NEW.geography::VARCHAR		/* Geography */);
		ELSIF (NEW.defaultstudyarea IS NOT NULL AND NEW.defaultstudyarea::text <> '')  THEN
			OPEN c2geog(NEW.defaultstudyarea);
			FETCH c2geog INTO c2bgeog_rec;
			CLOSE c2geog;
			IF c2bgeog_rec.geolevel_name IS NULL THEN
				PERFORM rif40_log_pkg.rif40_error(-20108, 'trigger_fct_rif40_geog_hierarchytable', 
					'Error: Default study area column % not found in T_RIF40_GEOLEVELS for geography: %',
					NEW.defaultstudyarea::VARCHAR	/* Default study area */,
					NEW.geography::VARCHAR		/* Geography */);
			END IF;
		END IF;
	END IF;

--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable() IS 'Check HIERARCHYTABLE exists.
Check postal_population_table if set and expected columns
Error range: -20100 to -20119 - RIF40_GEOG_HIERARCHYTABLE';

CREATE TRIGGER rif40_geog_hierarchytable
	BEFORE INSERT OR UPDATE OF geography, hierarchytable, postal_population_table, postal_point_column, defaultcomparea, defaultstudyarea ON rif40_geographies
	FOR EACH ROW
	WHEN ((NEW.hierarchytable IS NOT NULL AND NEW.hierarchytable::text <> '') OR (NEW.postal_population_table IS NOT NULL AND NEW.postal_population_table::text <> '') OR (NEW.postal_point_column IS NOT NULL AND NEW.postal_point_column::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable();
COMMENT ON TRIGGER rif40_geog_hierarchytable ON rif40_geographies IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()';

CREATE TRIGGER rif40_geog_hierarchytable_del
	BEFORE DELETE ON rif40_geographies
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable();
COMMENT ON TRIGGER rif40_geog_hierarchytable_del ON rif40_geographies IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_geog_hierarchytable()';

\i ../PLpgsql/rif40_trg_pkg/trigger_fct_rif40_outcomes_checks.sql

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_predefined_groups_checks_description>
<para>
Check condition for SQL injection
</para>
</trigger_rif40_predefined_groups_checks_description>
 */
--
-- -20460 to -20479 - RIF40_PREDEFINED_GROUPS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
BEGIN
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
-- Check condition for SQL injection
--
	PERFORM rif40_trg_pkg.rif40_sql_injection_check(
		'RIF40_PREDEFINED_GROUPS',
		NEW.predefined_group_name		/* Predefined group name */,
		NEW.predefined_group_description	/* Description */,
		NEW.outcome_type 			/* Outcome type */,
		'CONDITION', NEW.condition);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks() IS 'Check condition for SQL injection
-20460 to -20479 - RIF40_PREDEFINED_GROUPS';

CREATE TRIGGER rif40_predefined_groups_checks
	BEFORE INSERT OR UPDATE OF predefined_group_name, predefined_group_description, outcome_type, condition
	ON rif40_predefined_groups
	FOR EACH ROW
	WHEN ((NEW.predefined_group_name IS NOT NULL AND NEW.predefined_group_name::text <> '') OR (NEW.predefined_group_description IS NOT NULL AND NEW.predefined_group_description::text <> '') OR (NEW.outcome_type IS NOT NULL AND NEW.outcome_type::text <> '') OR (NEW.condition IS NOT NULL AND NEW.condition::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks();
COMMENT ON TRIGGER rif40_predefined_groups_checks ON rif40_predefined_groups IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()';

CREATE TRIGGER rif40_predefined_groups_checks_del
	BEFORE DELETE ON rif40_predefined_groups
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks();
COMMENT ON TRIGGER rif40_predefined_groups_checks_del ON rif40_predefined_groups IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_predefined_groups_checks()';

\i ../PLpgsql/rif40_trg_pkg/trigger_fct_rif40_study_shares_checks.sql
\i ../PLpgsql/rif40_trg_pkg/trigger_fct_rif40_tables_checks.sql

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_table_outcomes_checks_description>
<para>
Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
</para>
</trigger_rif40_table_outcomes_checks_description>
 */
--
-- -20440 to -20459 - RIF40_TABLE_OUTCOMES
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
        c1rto CURSOR(l_table VARCHAR) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = l_table;
	c1_rec RECORD;
BEGIN
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
--
	OPEN c1rto(NEW.numer_tab);
	FETCH c1rto INTO c1_rec;
	IF c1_rec.table_name IS NULL THEN
		CLOSE c1rto;
		PERFORM rif40_log_pkg.rif40_error(-20440, 'trigger_fct_rif40_table_outcomes_checks', '[20440] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) not found in RIF tables',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
	CLOSE c1rto;
--
-- Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
--
	IF NOT NEW.current_version_start_year BETWEEN c1_rec.year_start AND c1_rec.year_stop THEN
		PERFORM rif40_log_pkg.rif40_error(-20441, 'trigger_fct_rif40_table_outcomes_checks', '[20441] RIF40_TABLE_OUTCOMES outcome group name % current_version_start_year (%) not NOT between % and %',
			NEW.outcome_group_name::VARCHAR		/* Outcome group */,
			NEW.current_version_start_year::VARCHAR	/* Current version start year */,
			c1_rec.year_start::VARCHAR		/* Year start */,
			c1_rec.year_stop::VARCHAR		/* Year stop */);
	END IF;

--
-- Check numer_tab is a numerator
--
	IF c1_rec.isnumerator != 1 THEN
		PERFORM rif40_log_pkg.rif40_error(-20442, 'trigger_fct_rif40_table_outcomes_checks', '[20442] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) is not a numerator',
			NEW.outcome_group_name::VARCHAR	/* Outcome group */,
			NEW.numer_tab::VARCHAR 		/* Numerator table */);
	END IF;
--
	PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_rif40_table_outcomes_checks', '[20440-2] RIF40_TABLE_OUTCOMES outcome group name % numerator (%) OK',
		NEW.outcome_group_name::VARCHAR	/* Outcome group */,
		NEW.numer_tab::VARCHAR 		/* Numerator table */);
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks() IS 'Check current_version_start_year (if not NULL) BETWEEN rif40_tables.year_start AND rif40_tables.year_stop
Check numer_tab is a numerator
 
-20440 to -20459 - RIF40_TABLE_OUTCOMES';

CREATE TRIGGER rif40_table_outcomes_checks
	BEFORE INSERT OR UPDATE OF outcome_group_name, numer_tab, current_version_start_year
	ON rif40_table_outcomes
	FOR EACH ROW
	WHEN ((NEW.outcome_group_name IS NOT NULL AND NEW.outcome_group_name::text <> '') OR 
		(NEW.numer_tab IS NOT NULL AND NEW.numer_tab::text <> '') OR 
		(NEW.current_version_start_year IS NOT NULL AND NEW.current_version_start_year::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks();
COMMENT ON TRIGGER rif40_table_outcomes_checks ON rif40_table_outcomes IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()';
CREATE TRIGGER rif40_table_outcomes_checks_del
	BEFORE DELETE ON rif40_table_outcomes
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks();
COMMENT ON TRIGGER rif40_table_outcomes_checks_del ON rif40_table_outcomes IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_rif40_table_outcomes_checks()';

CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_rif40_version_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_rif40_version_checks_description>
<para>
Check - single column, populate schema_amended. Prevent DELETE or INSERT
</para>
</trigger_rif40_version_checks_description>
 */
--
-- Error range: -20160 to -20179 - RIF40_VERSION
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1vc CURSOR FOR
		SELECT COUNT(*) AS total
		  FROM rif40_version;
	c1_rec RECORD;
BEGIN
	IF TG_OP = 'INSERT' THEN
		OPEN c1vc;
		FETCH c1vc INTO c1_rec;
		CLOSE c1vc;
--
		IF c1_rec.total > 0 THEN
			PERFORM rif40_log_pkg.rif40_error(-20160, 'trigger_fct_rif40_version_checks', '[20160] Error: RIF40_VERSION INSERT disallowed, rows: %',
				c1_rec.total::VARCHAR /* rows */);
		END IF;
	ELSIF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20161, 'trigger_fct_rif40_version_checks', '[20161] Error: RIF40_VERSION DELETE disallowed');
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
--
		NEW.schema_amended := LOCALTIMESTAMP;
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_rif40_version_checks() IS 'Check - single column, populate schema_amended. Prevent DELETE or INSERT
Error range: -20160 to -20179 - RIF40_VERSION';

CREATE TRIGGER rif40_version_checks
	BEFORE INSERT OR UPDATE OF version ON rif40_version
	FOR EACH ROW
	WHEN ((NEW.version IS NOT NULL AND NEW.version::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_version_checks();
COMMENT ON TRIGGER rif40_version_checks ON rif40_version IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()';
CREATE TRIGGER rif40_version_checks_del
	BEFORE DELETE ON rif40_version
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_rif40_version_checks();
COMMENT ON TRIGGER rif40_version_checks_del ON rif40_version IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_rif40_version_checks()';

\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_studies_checks.sql
\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_study_areas_checks.sql

DROP TRIGGER IF EXISTS t_rif40_study_areas_checks2 ON "t_rif40_study_areas" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_study_areas_checks2_description>
<para>
Check - area_id
</para>
</trigger_t_rif40_study_areas_checks2_description>
 */
--
-- -20280 to -20299 - T_RIF40_STUDY_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
-- $Log: v4_0_postgres_triggers.sql,v $
-- Revision 1.6  2014/02/24 10:50:28  peterh
-- Full build from Oracle, including default study area and removal of year_start/stop min/max_age_group from T_RIF40_STUDIES
--
-- Still present in view
--
-- Revision 1.5  2013/09/25 12:12:22  peterh
-- Baseline after 2x full clean builds at Postgres level
-- TODO.txt uptodate
--
-- Revision 1.4  2013/09/18 15:20:32  peterh
-- Checkin at end of 6 week RIF focus. Got as far as SAHSULAND run study to completion for observed only
--
-- Revision 1.3  2013/09/02 14:08:33  peterh
--
-- Baseline after full trigger implmentation
--
-- Revision 1.2  2013/03/14 17:35:38  peterh
-- Baseline for TX to laptop
--
-- Revision 1.4  2013/02/14 10:48:39  peterh
-- Baseline aftyer clean build with screen mockup changes
--
-- Revision 1.12  2012/10/23 09:05:57  peterh
--
-- Baseline after full build of SAHSUland RIF schema including data
-- No triggers, Geo data and system error/logon triggers to be done
--
-- Revision 1.11  2012/09/14 15:44:53  peterh
-- Baseline after full review of check code and error messages
-- IG functionality added
--
-- Revision 1.10  2012/09/05 15:16:37  peterh
--
-- RIF update after initial build of postgres DB
--
-- Revision 1.9  2012/07/03 12:28:55  peterh
--
-- RIF schema as at 3/6/2012. All entities complete
--
-- Revision 1.8  2012/06/15 11:05:26  peterh
-- Check with working SQL generator (CREATE stmt only); bones of XML generator
-- Numerous lookup tables added.
-- Prepare for documentation
--
-- Revision 1.7  2012/05/22 15:29:41  peterh
--
-- Added RIF40_RESULTS, contextual_stats; more verification
--
-- Revision 1.6  2012/05/21 11:11:28  peterh
--
-- RIF investigattion, inv_covariates, study shares checks + SAHSU land example data
--
-- Revision 1.5  2012/04/26 15:49:48  peterh
-- Fixed view security problems
--
-- Revision 1.4  2012/04/13 15:05:02  peterh
--
-- Added RIF studies, investigations etc
--
-- Revision 1.3  2012/04/04 15:22:51  peterh
-- Easter baseline
--
-- Revision 1.2  2012/03/30 11:45:40  peterh
--
-- Baseline with working RIF40_NUM_DENOM
--
-- Revision 1.1  2012/03/28 15:39:19  peterh
--
-- Added check constraints and basic object table+column existance checks
--
-- Revision 1.2  2012/03/27 15:54:33  peterh
--
-- Added more V4 tables
--
-- Revision 1.1  2012/03/23 15:21:18  peterh
--
-- Moved from old RIF directory
--
-- Revision 1.2  2011/07/12 13:18:40  peterh
-- RIF baseline after Kerberosisation, re-doc and N_POP add
--
-- Revision 1.1  2011/05/27 10:31:21  peterh
--
-- Start of user level suppression support in RIF
--
	c1_cksa2 CURSOR (l_study_id  integer) IS
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cksa2 CURSOR IS
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cksa2 CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cksa2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial system load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cksa2;
		FETCH c4_cksa2 INTO c4_rec;
		CLOSE c4_cksa2;
		IF c4_rec.total = 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_study_areas_checks2',
				'[20300] T_RIF40_STUDY_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
     
--
-- Check - area_id
--
	OPEN c3_cksa2;
	FETCH c3_cksa2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20284, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no rif40_study_id_seq.CURRVAL study_id sequence found');
	END IF;
--
	CLOSE c3_cksa2;
	OPEN c1_cksa2(c3_rec.study_id);
	FETCH c1_cksa2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cksa2;
		PERFORM rif40_log_pkg.rif40_error(-20285, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS no study found for study_id: %',
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cksa2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_study_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.study_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cksa2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cksa2 INTO total;
		CLOSE c2_cksa2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20286, 'trigger_fct_t_rif40_study_areas_checks2',
				'T_RIF40_STUDY_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20287, 'trigger_fct_t_rif40_study_areas_checks2',
			'T_RIF40_STUDY_AREAS study_id: %; found % areas not in: %.%'||E'\n'||'SQL> %;',
			total::VARCHAR				/* Total */,
			c3_rec.study_id::VARCHAR		/* rif40_study_id_seq.CURRVAL study_id sequence */,
			c1_rec.hierarchytable::VARCHAR		/* Hierarchy table */,
			c1_rec.study_geolevel_name::VARCHAR	/* Study geolevel column name */,
		        sql_stmt::VARCHAR			/* SQL */ );
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2() IS 'Check - area_id';

CREATE TRIGGER t_rif40_study_areas_checks2
	AFTER INSERT ON "t_rif40_study_areas" FOR EACH STATEMENT
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2();
COMMENT ON TRIGGER t_rif40_study_areas_checks2 ON t_rif40_study_areas IS 'INSERT OR UPDATE OR DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_areas_checks2()';

DROP TRIGGER IF EXISTS t_rif40_comp_areas_checks2 ON "t_rif40_comparison_areas" CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_comp_areas_checks2_description>
<para>
Check - area_id; once per statement (for performance reasons)
</para>
</trigger_t_rif40_comp_areas_checks2_description>
 */
--
-- -20300 to -20319 - T_RIF40_COMPARISON_AREAS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1_cack2 CURSOR (l_study_id  integer) FOR
		SELECT a.study_id, a.study_geolevel_name, a.comparison_geolevel_name, b.hierarchytable
		  FROM t_rif40_studies a, rif40_geographies b
		 WHERE a.geography = b.geography
		   AND a.study_id  = l_study_id;
	c3_cack2 CURSOR FOR
		SELECT currval('rif40_study_id_seq'::regclass) AS study_id;
	c1_rec RECORD;
	c3_rec RECORD;
	c4_cack2 CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c4_rec RECORD;
--
	c2_cack2 REFCURSOR;
	sql_stmt	varchar(2000);
	total		integer;
BEGIN
--
-- Efffectively disable check during initial syustem load
--
	IF NOT TG_OP = 'DELETE' AND USER = 'rif40' THEN
		OPEN c4_cack2;
		FETCH c4_cack2 INTO c4_rec;
		CLOSE c4_cack2;
		IF c4_rec.total = 0 THEN  
			/* Allowed during build before first result is added to system or before Kerberos update */
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_comp_areas_checks2',
				'[20300] T_RIF40_COMPARISON_AREAS username: % allowed during build before first result is added to system [CHECK DISABLED]',
				USER::VARCHAR		/* User */);
			RETURN NEW;
		END IF;
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
  
--
-- Check - area_id
--
	OPEN c3_cack2;
	FETCH c3_cack2 INTO c3_rec;
	IF NOT FOUND OR coalesce(c3_rec.study_id::text, '') = '' THEN
		CLOSE c3_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20304, 'trigger_fct_t_rif40_comp_areas_checks2', 'T_RIF40_COMPARISON_AREAS no study_id found');
	END IF;
	CLOSE c3_cack2;
	OPEN c1_cack2(c3_rec.study_id);
	FETCH c1_cack2 INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_cack2;
		PERFORM rif40_log_pkg.rif40_error(-20305, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS no comparison found for study_id: %',
			c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */);
	END IF;
	CLOSE c1_cack2;
	sql_stmt:='SELECT COUNT(area_id) AS total FROM ('||E'\n'||
			'SELECT area_id FROM t_rif40_comparison_areas WHERE study_id = $1'||E'\n'||
			'EXCEPT '||E'\n'||
			'SELECT '||LOWER(c1_rec.comparison_geolevel_name)||' FROM '||c1_rec.hierarchytable||') a';
	BEGIN
		OPEN c2_cack2 FOR EXECUTE sql_stmt USING c3_rec.study_id;
		FETCH c2_cack2 INTO total;
		CLOSE c2_cack2;
	EXCEPTION
		WHEN others THEN
			PERFORM rif40_log_pkg.rif40_error(-20306, 'trigger_fct_t_rif40_comp_areas_checks2',
				'T_RIF40_COMPARISON_AREAS study_id: % % raised by: %',
				c3_rec.study_id::VARCHAR	/* rif40_study_id_seq.CURRVAL study_id sequence */,
				sqlerrm::VARCHAR		/* Error */,
				sql_stmt::VARCHAR		/* SQL */);

	END;
	IF total > 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20307, 'trigger_fct_t_rif40_comp_areas_checks2', 
			'T_RIF40_COMPARISON_AREAS study_id: %; found % areas not in: %.%',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG2', 'trigger_fct_t_rif40_comp_areas_checks2', 
			'[20307] T_RIF40_COMPARISON_AREAS study_id: %; found % areas in: %.%'||E'\n'||'SQL> %;',
			c3_rec.study_id::VARCHAR			/* rif40_study_id_seq.CURRVAL study_id sequence */,
			total::VARCHAR					/* Total */,
			c1_rec.hierarchytable::VARCHAR			/* Hierarchy table */,
			c1_rec.comparison_geolevel_name::VARCHAR	/* Comparison geolevel column name */,
			sql_stmt::VARCHAR	 		       /* SQL */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2() IS 'Check - area_id; once per statement (for performance reasons)';

CREATE TRIGGER t_rif40_comp_areas_checks2
	AFTER INSERT ON "t_rif40_comparison_areas" FOR EACH STATEMENT
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2();
COMMENT ON TRIGGER t_rif40_comp_areas_checks2 ON t_rif40_comparison_areas IS 'INSERT trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_comp_areas_checks2()';

\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_comparison_areas_checks.sql
\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_investigations_checks.sql
\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_inv_conditions_checks.sql
\i ../PLpgsql/rif40_trg_pkg/trigger_fct_t_rif40_inv_covariates_checks.sql

DROP TRIGGER IF EXISTS t_rif40_geolevels_checks ON t_rif40_geolevels CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, &lt;GEOLEVEL_NAME&gt; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.&lt;T_RIF40_GEOLEVELS.GEOLEVEL_NAME&gt;, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check &lt;RIF40_GEOGRAPHIES.HIERARCHYTABLE&gt;.&lt;GEOLEVEL_NAME&gt; column exists
Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES

TO be added:

Check
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20120 to -20134 - T_RIF40_GEOLEVELS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1_geock CURSOR (l_schema  varchar, l_table  varchar, l_column  varchar) IS
		SELECT column_name
		  FROM information_schema.columns
		 WHERE table_schema = LOWER(l_schema)
		   AND table_name   = LOWER(l_table)
		   AND column_name  = LOWER(l_column);
	c2_geock CURSOR (l_geography  varchar) IS
		SELECT hierarchytable, postal_population_table
		  FROM rif40_geographies
		 WHERE geography = l_geography;
	c4_geock CURSOR IS
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;
	c1_rec RECORD;
	c2_rec RECORD;
	c4_rec RECORD;
--
	owner		varchar(30);
	table_or_view	varchar(30);
BEGIN
--
	OPEN c4_geock;
	FETCH c4_geock INTO c4_rec;
	CLOSE c4_geock;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSIF TG_OP = 'INSERT' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		RETURN NEW;
	END IF;
--
-- Check COVARIATE_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.covariate_table);
	table_or_view:=NEW.covariate_table;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20120, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE (%) not found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			'[20120] T_RIF40_GEOLEVELS COVARIATE_TABLE (%) found',
			NEW.covariate_table::VARCHAR 		/* covariate_table */);
	END IF;
--
-- Check YEAR, <GEOLEVEL_NAME> exist in COVARIATE_TABLE
--
	OPEN c1_geock(owner, table_or_view, 'YEAR');
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20121, 'trigger_fct_t_rif40_geolevels_checks',
			'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: ',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20121] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) found for geolevel_name: ',
			NEW.covariate_table::VARCHAR     	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20122, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR   	 	/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20122] T_RIF40_GEOLEVELS COVARIATE_TABLE column (%.%) not found for geolevel_name: %',
			NEW.covariate_table::VARCHAR		/* Covariate table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE
--
	owner:=rif40_sql_pkg.rif40_object_resolve(NEW.lookup_table);
	table_or_view:=NEW.lookup_table;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(table_or_view::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20123, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE (%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR  	     	/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (table_or_view IS NOT NULL AND table_or_view::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20123] T_RIF40_GEOLEVELS LOOKUP_TABLE (%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN exists
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20124, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20124] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.lookup_desc_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20125, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20125] T_RIF40_GEOLEVELS LOOKUP_TABLE column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.lookup_desc_column::VARCHAR		/* LOOKUP_TABLE column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> column exist
--
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidxcoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20126, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR    	   	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20126] T_RIF40_GEOLEVELS CENTROIDXCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column		/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name			/* Geolevel name */);
	END IF;
	c1_rec.column_name:=NULL;
	OPEN c1_geock(owner, table_or_view, NEW.centroidycoordinate_column);
	FETCH c1_geock INTO c1_rec;
	CLOSE c1_geock;
	IF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_error(-20127, 'trigger_fct_t_rif40_geolevels_checks',
			 'Error: T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) not found for geolevel_name: %',
			NEW.lookup_table::VARCHAR		/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	ELSIF (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 '[20127] T_RIF40_GEOLEVELS CENTROIDYCOORDINATE_COLUMN column (%.%) found for geolevel_name: %',
			NEW.lookup_table::VARCHAR	/* Lookup table */,
			NEW.centroidxcoordinate_column::VARCHAR	/* CENTROIDXCOORDINATE_COLUMN column */,
			NEW.geolevel_name::VARCHAR		/* Geolevel name */);
	END IF;
--
-- Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
--
	OPEN c2_geock(NEW.geography);
	FETCH c2_geock INTO c2_rec;
	CLOSE c2_geock;
	IF (c2_rec.hierarchytable IS NOT NULL AND c2_rec.hierarchytable::text <> '') THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.hierarchytable);
		table_or_view:=c2_rec.hierarchytable;
		IF coalesce(owner::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20128, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE (%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20128] RIF40_GEOGRAPHIES HIERARCHYTABLE (%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, c2_rec.hierarchytable, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20129, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) not found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSIF (NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') AND (c1_rec.column_name IS NOT NULL AND c1_rec.column_name::text <> '') THEN
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20129] RIF40_GEOGRAPHIES HIERARCHYTABLE geolevel column (%.%) found for geolevel_name: %',
				c2_rec.hierarchytable::VARCHAR		/* HIERARCHYTABLE */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
-- Check &lt;postal_population_table&gt;.&lt;GEOLEVEL_NAME&gt; column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES
--
	IF (c2_rec.postal_population_table IS NOT NULL AND c2_rec.postal_population_table::text <> '') AND
		(
		 ((NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') AND (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '')) OR
		 ((NEW.centroidsfile IS NOT NULL AND NEW.centroidsfile::text <> ''))) THEN
		owner:=rif40_sql_pkg.rif40_object_resolve(c2_rec.postal_population_table);
		table_or_view:=c2_rec.postal_population_table;
		IF coalesce(table_or_view::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20130, 'trigger_fct_t_rif40_geolevels_checks',
			 	'Error: RIF40_GEOGRAPHIES POSTAL_POPULATION_TABLE (%) not found when set',
		   	     	c2_rec.postal_population_table::VARCHAR 	/* hierarchy table */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20130] RIF40_GEOGRAPHIES POSTAL_POINT_COLUMN (%) found',
				c2_rec.postal_population_table::VARCHAR		/* postal population table */);
		END IF;
		c1_rec.column_name:=NULL;
		OPEN c1_geock(owner, table_or_view, NEW.geolevel_name);
		FETCH c1_geock INTO c1_rec;
		CLOSE c1_geock;
		IF coalesce(c1_rec.column_name::text, '') = '' THEN
			PERFORM rif40_log_pkg.rif40_error(-20131, 'trigger_fct_t_rif40_geolevels_checks',
				'Error: RIF40_GEOGRAPHIES geolevel column (%.%) not found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		ELSE
			PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_geolevels_checks',
			 	'[20131] RIF40_GEOGRAPHIES geolevel column (%.%) found',
				c2_rec.postal_population_table::VARCHAR	/* postal population table */,
				NEW.geolevel_name::VARCHAR		/* Geolevel name */);
		END IF;
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks() IS '
Check LOOKUP_TABLE, COVARIATE_TABLE exist.
Check YEAR, <GEOLEVEL_NAME>; exist in COVARIATE_TABLE
Check LOOKUP_TABLE.<T_RIF40_GEOLEVELS.GEOLEVEL_NAME>, LOOKUP_TABLE.LOOKUP_DESC_COLUMN,
LOOKUP_TABLE.<CENTROIDXCOORDINATE_COLUMN>, LOOKUP_TABLE.<CENTROIDYCOORDINATE_COLUMN> columns exist
Check <RIF40_GEOGRAPHIES.HIERARCHYTABLE>.<GEOLEVEL_NAME> column exists
Check <postal_population_table>.<GEOLEVEL_NAME> column exists if POSTAL_POPULATION_TABLE set if RIF40_GEOGAPHIES'; 

CREATE TRIGGER t_rif40_geolevels_checks
	BEFORE INSERT OR UPDATE OF lookup_table, covariate_table, lookup_desc_column, geography, geolevel_name ON t_rif40_geolevels
	FOR EACH ROW	
	WHEN ((NEW.lookup_table IS NOT NULL AND NEW.lookup_table::text <> '') OR (NEW.covariate_table IS NOT NULL AND NEW.covariate_table::text <> '') OR (NEW.lookup_desc_column IS NOT NULL AND NEW.lookup_desc_column::text <> '') OR
	      (NEW.centroidxcoordinate_column IS NOT NULL AND NEW.centroidxcoordinate_column::text <> '') OR (NEW.centroidycoordinate_column IS NOT NULL AND NEW.centroidycoordinate_column::text <> '') OR (NEW.geography IS NOT NULL AND NEW.geography::text <> '') OR (NEW.geolevel_name IS NOT NULL AND NEW.geolevel_name::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks();
COMMENT ON TRIGGER t_rif40_geolevels_checks ON t_rif40_geolevels IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()';

CREATE TRIGGER t_rif40_geolevels_checks_del
	BEFORE DELETE ON t_rif40_geolevels
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks();
COMMENT ON TRIGGER t_rif40_geolevels_checks_del ON t_rif40_geolevels IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_geolevels_checks()';
 
DROP TRIGGER IF EXISTS t_rif40_num_denom_checks ON t_rif40_num_denom CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_num_denom_checks_description>
<para>
Check numerator_table really is a numerator and likewise for the denominator
</para>
</trigger_t_rif40_num_denom_checks_description>
 */
--
-- $Author: peterh $
-- $timestamp: 2012/04/26 15:49:46 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c1_rnd CURSOR (l_table varchar) FOR
		SELECT *
		  FROM rif40_tables
		 WHERE table_name = UPPER(l_table);
	c1_rec RECORD;
BEGIN

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	END IF;
 
	OPEN c1_rnd(NEW.numerator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20291, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator not found in RIF40_TABLES: %',
			NEW.numerator_table::VARCHAR /* numerator table */);
	ELSIF c1_rec.isnumerator != 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20292, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM numerator in RIF40_TABLES: % is not a numerator table,',
			NEW.numerator_table::VARCHAR /* numerator table */);
	END IF;
	CLOSE c1_rnd;
--
	OPEN c1_rnd(NEW.denominator_table);
	FETCH c1_rnd INTO c1_rec;
	IF NOT FOUND THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20293, 'trigger_fct_t_rif40_num_denom_checks',  
			EXCEPTION 'T_RIF40_NUM_DENOM denominator not found in RIF40_TABLES: %',
			NEW.denominator_table::VARCHAR /* denominator table */);
	ELSIF c1_rec.isnumerator = 1 THEN
		CLOSE c1_rnd;
		PERFORM rif40_log_pkg.rif40_error(-20294, 'trigger_fct_t_rif40_num_denom_checks',  
			'T_RIF40_NUM_DENOM denominator in RIF40_TABLES: % is not a denominator table,',
			NEW.denominator_table::VARCHAR /* denominator table */);
	END IF;
	CLOSE c1_rnd;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END;
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_num_denom_checks
	BEFORE INSERT OR UPDATE OF geography, numerator_table, denominator_table ON t_rif40_num_denom
	FOR EACH ROW	
	WHEN ((NEW.geography IS NOT NULL AND NEW.geography::text <> '') OR (NEW.numerator_table IS NOT NULL AND NEW.numerator_table::text <> '') OR (NEW.denominator_table IS NOT NULL AND NEW.denominator_table::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks();
CREATE TRIGGER t_rif40_num_denom_checks_del
	BEFORE DELETE ON t_rif40_num_denom
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks();

GRANT EXECUTE ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() TO rif_user;
GRANT EXECUTE ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() TO rif_manager;

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks() IS 'Check numerator_table really is a numerator and likewise for the denominator';
COMMENT ON TRIGGER t_rif40_num_denom_checks ON t_rif40_num_denom IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';
COMMENT ON TRIGGER t_rif40_num_denom_checks_del ON t_rif40_num_denom IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_num_denom_checks()';

DROP TRIGGER IF EXISTS t_rif40_user_projects_checks ON t_rif40_user_projects CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_geolevels_checks_description>
<para>
Check username exists and is a RIF user
Check project has not ended
</para>
</trigger_t_rif40_geolevels_checks_description>
 */
--
-- Error range: -20520 to -20529 - T_RIF40_USER_PROJECTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c2_rup CURSOR(l_project  varchar) IS
		SELECT *
		  FROM t_rif40_projects
		 WHERE project = l_project;
	c4_rup CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;  
        c2_rec RECORD;
        c4_rec RECORD;
BEGIN
	OPEN c4_rup;
	FETCH c4_rup INTO c4_rec;
	CLOSE c4_rup;    
--
-- Check username exists and is a RIF user
--
	IF USER = 'rif40' THEN
		IF NOT TG_OP = 'DELETE' AND USER = 'rif40' AND (c4_rec.total = 0 OR strpos(OLD.username, '@PRIVATE.NET') > 0) THEN
			/* Allowed during build before first result is added to system or before Kerberos update */
			RETURN NEW;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20522,  'trigger_fct_t_rif40_user_projects_checks',
				'T_RIF40_USER_PROJECTS project: % rif40 user insert only allowed during build before first result is added to system',
				OLD.project::VARCHAR 		/* project */);
		END IF; 
        ELSIF NOT (pg_has_role(USER, 'rif_user', 'USAGE') AND pg_has_role(USER, 'rif_manager', 'USAGE')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS user: % is not a RIF_USER',
			USER::VARCHAR 	/* username */);
	END IF;

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		 	'[20520] T_RIF40_USER_PROJECTS user: % is a RIF_USER',
			OLD.username::VARCHAR 	/* username */);
		RETURN OLD;
	END IF;
--
-- Check table username is a RIF user
--
	IF c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */ 
		NULL;
        ELSIF NOT (pg_has_role(NEW.username, 'rif_user', 'USAGE') AND pg_has_role(NEW.username, 'rif_manager', 'USAGE')) THEN 
		PERFORM rif40_log_pkg.rif40_error(-20520, 'trigger_fct_t_rif40_user_projects_checks',
		 	'Error: T_RIF40_USER_PROJECTS username: % is not a RIF_USER',
			NEW.username::VARCHAR 	/* username */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		       	'[20520] T_RIF40_USER_PROJECTS username: % is a RIF_USER',
   	            	NEW.username::VARCHAR 	/* username */);
      	END IF;         
--
-- Check project has not ended
--
	OPEN c2_rup(NEW.project);
	FETCH c2_rup INTO c2_rec;
	IF coalesce(c2_rec.date_ended::text, '') = '' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'[20521] T_RIF40_USER_PROJECTS project: % no end set',
			NEW.project::VARCHAR 		/* project */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: % [IGNORED INITIAL LOAD]',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSIF c2_rec.date_ended < LOCALTIMESTAMP AND c4_rec.total > 0 THEN 
		PERFORM rif40_log_pkg.rif40_error(-20521, 'trigger_fct_t_rif40_user_projects_checks',
		  	'Error: T_RIF40_USER_PROJECTS project: % ended on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	ELSE
		PERFORM rif40_log_pkg.rif40_log('DEBUG1', 'trigger_fct_t_rif40_user_projects_checks',
			'[20521] T_RIF40_USER_PROJECTS project: % ends on: %',
			NEW.project::VARCHAR 		/* project */,
			c2_rec.date_ended::VARCHAR	/* date_ended */);
	END IF;
	CLOSE c2_rup;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_user_projects_checks
	BEFORE INSERT OR UPDATE OF project, username ON t_rif40_user_projects
	FOR EACH ROW	
	WHEN ((NEW.project IS NOT NULL AND NEW.project::text <> '') OR (NEW.username IS NOT NULL AND NEW.username::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks();
CREATE TRIGGER t_rif40_user_projects_checks_del
	BEFORE DELETE ON t_rif40_user_projects
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks();
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks() IS 'Check username exists and is a RIF user Check project has not ended';
COMMENT ON TRIGGER t_rif40_user_projects_checks ON t_rif40_user_projects IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()';
COMMENT ON TRIGGER t_rif40_user_projects_checks_del ON t_rif40_user_projects IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_user_projects_checks()';

DROP TRIGGER IF EXISTS t_rif40_results_checks ON t_rif40_results CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_results_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_results_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results
</para>
</trigger_t_rif40_results_checks_description>
 */
--
-- -20340 to -20359 - T_RIF40_RESULTS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--
	c4_resck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_contextual_stats /* Loaded after t_rif40_results */
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_resck;
	FETCH c4_resck INTO c4_rec;
	CLOSE c4_resck;

--
-- T_RIF40_RESULTS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20340, 'trigger_fct_t_rif40_results_checks',
		 		'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study id */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.band_id::VARCHAR	/* Band ID */,
				NEW.genders::VARCHAR 	/* genders */,
				NEW.adjusted::VARCHAR	/* adjusted */,
				NEW.direct_standardisation::VARCHAR	/* Direct standardisation */,
				NEW.username::VARCHAR 	/* Record username */,
				USER::VARCHAR		/* User */);
		END IF;
/*	ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20341, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	/- Study id -/,
			NEW.inv_id::VARCHAR	/- Investigation -/,
			NEW.band_id::VARCHAR	/- Band ID -/,
			NEW.genders::VARCHAR 	/- genders -/,
			NEW.adjusted::VARCHAR	/- adjusted -/,
			NEW.direct_standardisation::VARCHAR	/- Direct standardisation -/,
			NEW.username::VARCHAR 	/- Record username -/,
			USER::VARCHAR		/- User -/);           */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20342, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % UPDATE not allowed on T_RIF40_RESULTS',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR 	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20343, 'trigger_fct_t_rif40_results_checks',
		 	'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % DELETE only allowed on own records in T_RIF40_RESULTS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.username::VARCHAR	/* INSERT username */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.genders::VARCHAR 	/* genders */,
			OLD.adjusted::VARCHAR	/* adjusted */,
			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--

--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
--       	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--	       	 	'[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--       		OLD.study_id::VARCHAR	/* Study id */,
--			OLD.inv_id::VARCHAR	/* Investigation */,
--			OLD.band_id::VARCHAR	/* Band ID */,
--			OLD.genders::VARCHAR 	/* genders */,
--			OLD.adjusted::VARCHAR	/* adjusted */,
--			OLD.direct_standardisation::VARCHAR	/* Direct standardisation */);
--
		RETURN OLD;
	END IF;
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_results_checks',
--		  '[20340-3] T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
--		NEW.genders::VARCHAR 	/* genders */,
--		NEW.adjusted::VARCHAR	/* adjusted */,
--		NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);

             
--
-- Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95
--   	   smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
--	   are NULL for directly standardised results
--
	IF NEW.direct_standardisation = 1 AND c4_rec.total > 0 /* Not during build before first result is added to system */ AND (
		(NEW.relative_risk IS NOT NULL AND NEW.relative_risk::text <> '') OR
		(NEW.smoothed_relative_risk IS NOT NULL AND NEW.smoothed_relative_risk::text <> '') OR
		(NEW.posterior_probability IS NOT NULL AND NEW.posterior_probability::text <> '') OR
		(NEW.posterior_probability_lower95 IS NOT NULL AND NEW.posterior_probability_lower95::text <> '') OR
		(NEW.posterior_probability_upper95 IS NOT NULL AND NEW.posterior_probability_upper95::text <> '') OR
		(NEW.smoothed_smr IS NOT NULL AND NEW.smoothed_smr::text <> '') OR
		(NEW.smoothed_smr_lower95 IS NOT NULL AND NEW.smoothed_smr_lower95::text <> '') OR
		(NEW.smoothed_smr_upper95 IS NOT NULL AND NEW.smoothed_smr_upper95::text <> '') OR
		(NEW.residual_relative_risk IS NOT NULL AND NEW.residual_relative_risk::text <> '') OR
		(NEW.residual_rr_lower95 IS NOT NULL AND NEW.residual_rr_lower95::text <> '') OR
		(NEW.residual_rr_upper95 IS NOT NULL AND NEW.residual_rr_upper95::text <> '')) THEN
		PERFORM rif40_log_pkg.rif40_error(-20344, 'trigger_fct_t_rif40_results_checks',
			'T_RIF40_RESULTS study: % investigation: % Band ID: % genders: % adjusted: % direct standardisation: % Expecting NULL relative_risk with direct standardised results',
			NEW.study_id::VARCHAR	/* Study id */,
			NEW.inv_id::VARCHAR	/* Inverstigation */,
			NEW.band_id::VARCHAR	/* Band ID */,
			NEW.genders::VARCHAR	/* genders */,
			NEW.adjusted::VARCHAR	/* adjusted */,
			NEW.direct_standardisation::VARCHAR	/* Direct standardisation */);
	END IF;
--
	IF TG_OP = 'DELETE' THEN
		RETURN OLD;
	ELSE  	
		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_results_checks
	BEFORE INSERT OR UPDATE OF username, study_id, inv_id, band_id, genders, adjusted, direct_standardisation,
				relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
				smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	ON t_rif40_results
	FOR EACH ROW	
	WHEN ((NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_results_checks();
CREATE TRIGGER t_rif40_results_checks_del
	BEFORE DELETE ON t_rif40_results
	FOR EACH ROW	
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_results_checks();
COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_results_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
Check - relative_risk, smoothed_relative_risk, posterior_probability, posterior_probability_lower95, posterior_probability_upper95,
  	smoothed_smr, smoothed_smr_lower95, smoothed_smr_upper95, residual_relative_risk, residual_rr_lower95, residual_rr_upper95
	are NULL for directly standardised results   ';
COMMENT ON TRIGGER t_rif40_results_checks ON t_rif40_results IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()';
COMMENT ON TRIGGER t_rif40_results_checks_del ON t_rif40_results IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_results_checks()';

DROP TRIGGER IF EXISTS t_rif40_contextualstats_checks ON t_rif40_contextual_stats CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_t_rif40_contextual_stats_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_t_rif40_contextual_stats_checks_description>
 */
--
-- -20360 to -20379 - T_RIF40_CONTEXTUAL_STATS
--
-- $Author: peterh $
-- $timestamp: 2012/10/23 09:05:57 $
-- Type: PL/SQL trigger
-- $RCSfile: v4_0_postgres_triggers.sql,v $
-- $Source: /home/EPH/CVS/repository/SAHSU/projects/rif/V4.0/database/postgres/psql_scripts/v4_0_postgres_triggers.sql,v $
-- $Revision: 1.6 $
-- $State: Exp $
-- $Locker:  $
--

	c4_cstck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_cstck;
	FETCH c4_cstck INTO c4_rec;
	CLOSE c4_cstck; 
--
-- T_RIF40_CONTEXTUAL_STATS: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' AND c4_rec.total = 0 THEN /* Allowed duing build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20360, 'trigger_fct_t_rif40_contextualstats_checks',
			 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.inv_id::VARCHAR	/* Investigation */,
				NEW.area_id::VARCHAR	/* Area */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20361, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.inv_id::VARCHAR	-* Investigation *-,
			NEW.area_id::VARCHAR	-* Area *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20362, 'trigger_fct_t_rif40_contextualstats_checks',
		 	'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: UPDATE not allowed on T_RIF40_CONTEXTUAL_STATS',
			NEW.study_id::VARCHAR	/* Study */,
			NEW.inv_id::VARCHAR	/* Investigation */,
			NEW.area_id::VARCHAR	/* Area */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20363, 'trigger_fct_t_rif40_contextualstats_checks',
			'T_RIF40_CONTEXTUAL_STATS study: % investigation: % area id: DELETE only allowed on own records in T_RIF40_CONTEXTUAL_STATS, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.area_id::VARCHAR	/* Area */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
	       	 	'[20360-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
			OLD.inv_id::VARCHAR	/* Investigation */,
			OLD.band_id::VARCHAR	/* Band ID */,
			OLD.area_id::VARCHAR	/* Area ID */);   
		RETURN OLD;
	ELSE  	
--	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_contextualstats_checks',
--		  '[20340-3] T_RIF40_CONTEXTUAL_STATS study: % investigation: % Band ID: % area ID: % CRUD checks OK',
--		NEW.study_id::VARCHAR	/* Study id */,
--		NEW.inv_id::VARCHAR	/* Investigation */,
--		NEW.band_id::VARCHAR	/* Band ID */,
-- 		NEW.area_id::VARCHAR	/* Area ID */);   

		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_contextualstats_checks
	BEFORE INSERT OR UPDATE OF area_id, username, study_id, inv_id,
		area_population, area_observed, total_comparision_population, variance_high, variance_low
	ON t_rif40_contextual_stats
	FOR EACH ROW
	WHEN ((NEW.username IS NOT NULL AND NEW.username::text <> '') OR (NEW.study_id IS NOT NULL AND NEW.study_id::text <> '') OR (NEW.inv_id IS NOT NULL AND NEW.inv_id::text <> '') OR (NEW.area_id IS NOT NULL AND NEW.area_id::text <> ''))
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks();

CREATE TRIGGER t_rif40_contextualstats_checks_del
	BEFORE DELETE ON t_rif40_contextual_stats
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_contextualstats_checks ON t_rif40_contextual_stats IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()';
COMMENT ON TRIGGER t_rif40_contextualstats_checks_del ON t_rif40_contextual_stats IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_contextualstats_checks()';


DROP TRIGGER IF EXISTS trigger_fct_t_rif40_study_sql_log_checks ON t_rif40_study_sql_log CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_fct_t_rif40_study_sql_log_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_log_checks_description>

-- -20560 to -20579 - T_RIF40_STUDY_SQL_LOG  
*/
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL_LOG: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20560, 'trigger_fct_t_rif40_study_sql_log_checks',
			 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not USER: %',
				NEW.study_id::VARCHAR	/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
				NEW.username::VARCHAR	/* New user */,
				USER::VARCHAR		/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20561, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *-,
			NEW.username::VARCHAR	-* New user *-,
			USER::VARCHAR		-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20562, 'trigger_fct_t_rif40_study_sql_log_checks',
		 	'T_RIF40_STUDY_SQL_LOG study: % statement number: % UPDATE not allowed on T_RIF40_STUDY_SQL_LOG',
			NEW.study_id::VARCHAR	/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20563, 'trigger_fct_t_rif40_study_sql_log_checks',
			'T_RIF40_STUDY_SQL_LOG study: % statement number: % DELETE only allowed on own records in T_RIF40_STUDY_SQL_LOG, record owned by: %',
			OLD.study_id::VARCHAR	/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,
			OLD.username::VARCHAR	/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
			OLD.study_id::VARCHAR	/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */);
		RETURN OLD;
	ELSE  	
--	      	PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_log_checks',
--			'[20340-3] T_RIF40_STUDY_SQL_LOG study: % statement number: % CRUD checks OK',
--			NEW.study_id::VARCHAR	/* Study id */,
--			NEW.statement_number::VARCHAR	/* Statement number */);    

		RETURN NEW;
	END IF;
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_study_sql_log_checks
	BEFORE INSERT OR UPDATE OF username, study_id, statement_type, statement_number, log_message, log_sqlcode, rowcount, start_time, elapsed_time, audsid
	ON t_rif40_study_sql_log
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks();

CREATE TRIGGER t_rif40_study_sql_log_checks_del
	BEFORE DELETE ON t_rif40_study_sql_log
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_study_sql_log_checks ON t_rif40_study_sql_log IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()';
COMMENT ON TRIGGER t_rif40_study_sql_log_checks_del ON t_rif40_study_sql_log IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_log_checks()';

DROP TRIGGER IF EXISTS trigger_fct_t_rif40_study_sql_checks ON t_rif40_study_sql CASCADE;
CREATE OR REPLACE FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks() RETURNS trigger AS $BODY$
DECLARE
/*
<trigger_fct_t_rif40_study_sql_checks_description>
<para>
Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.
</para>
</trigger_fct_t_rif40_study_sql_checks_description>

-- -20540 to -20549 - T_RIF40_STUDY_SQL_LOG  
 */
	c4_sqllogck CURSOR FOR
		SELECT COUNT(study_id) AS total
		  FROM (
		SELECT study_id
		  FROM t_rif40_results
		 LIMIT 1) a;    
	c4_rec RECORD;
BEGIN
	OPEN c4_sqllogck;
	FETCH c4_sqllogck INTO c4_rec;
	CLOSE c4_sqllogck; 
--
-- T_RIF40_STUDY_SQL: Check - USERNAME is Kerberos USER on INSERT
--			Check - audsid is SYS_CONTEXT('USERENV', 'SESSIONID') on INSERT
-- 			Check - UPDATE not allowed
--			Check - DELETE only allowed on own records
--
	IF NOT TG_OP = 'DELETE' AND NEW.username != USER THEN
		IF USER = 'rif40' /* AND c4_rec.total = 0 */ THEN /* [ALWAYS] Allowed during build before first result is added to system */
			NULL;
		ELSE
			PERFORM rif40_log_pkg.rif40_error(-20540, 'trigger_fct_t_rif40_study_sql_checks',
			 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not USER: %',
				NEW.study_id::VARCHAR		/* Study */,
				NEW.statement_number::VARCHAR	/* Statement number */,
		       		NEW.line_number::VARCHAR	/* Line number */,
				NEW.username::VARCHAR		/* New user */,
				USER::VARCHAR			/* Database user */);
		END IF;
 /*       ELSIF INSTR(NEW.username, '@PRIVATE.NET') = 0 THEN
		PERFORM rif40_log_pkg.rif40_error(-20541, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % username: % is not a Kerberos USER: %',
			NEW.study_id::VARCHAR	-* Study *-,
			NEW.statement_number::VARCHAR	-* statement_number *,   
		       	NEW.line_number::VARCHAR	-* Line number *-,
			NEW.username::VARCHAR		-* New user *-,
			USER::VARCHAR			-* Database user *-);    */
	ELSIF TG_OP = 'UPDATE' THEN
		PERFORM rif40_log_pkg.rif40_error(-20542, 'trigger_fct_t_rif40_study_sql_checks',
		 	'T_RIF40_STUDY_SQL study: % statement number: % line: % UPDATE not allowed on T_RIF40_STUDY_SQL',
			NEW.study_id::VARCHAR		/* Study */,
		       	NEW.statement_number::VARCHAR	/* Statement number */,   
		       	NEW.line_number::VARCHAR	/* Line number */);
	ELSIF TG_OP = 'DELETE' AND OLD.username != USER THEN
		PERFORM rif40_log_pkg.rif40_error(-20543, 'trigger_fct_t_rif40_study_sql_checks',
			'T_RIF40_STUDY_SQL study: % statement number: % line: % DELETE only allowed on own records in T_RIF40_STUDY_SQL, record owned by: %',
			OLD.study_id::VARCHAR		/* Study */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */,
			OLD.username::VARCHAR		/* INSERT username */);
	END IF;
--
-- End of delete checks
--
	IF TG_OP = 'DELETE' THEN
		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
	       	 	'[20360-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
			OLD.study_id::VARCHAR		/* Study id */,
		       	OLD.statement_number::VARCHAR	/* Statement number */,   
		       	OLD.line_number::VARCHAR	/* Line number */);
		RETURN OLD;
	ELSE  	
--		PERFORM rif40_log_pkg.rif40_log('DEBUG3', 'trigger_fct_t_rif40_study_sql_checks',
--			'[20340-3] T_RIF40_STUDY_SQL study: % statement number: % line: % CRUD checks OK',
-- 	     		NEW.study_id::VARCHAR		/* Study id */,
-- 		     	NEW.statement_number::VARCHAR	/* Statement number */,    
--		       	NEW.line_number::VARCHAR	/* Line number */);

		RETURN NEW;
	END IF;      
END; 
$BODY$
LANGUAGE 'plpgsql';

CREATE TRIGGER t_rif40_study_sql_checks
	BEFORE INSERT OR UPDATE OF username, study_id, statement_type, statement_number, sql_text, line_number
	ON t_rif40_study_sql
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks();

CREATE TRIGGER t_rif40_study_sql_checks_del
	BEFORE DELETE ON t_rif40_study_sql
	FOR EACH ROW
	EXECUTE PROCEDURE rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks();

COMMENT ON FUNCTION rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks() IS 'Check - USER exists.
Check - USER is Kerberos USER on INSERT.
Check - UPDATE not allowed.
Check - DELETE only allowed on own records.';
COMMENT ON TRIGGER t_rif40_study_sql_checks ON t_rif40_study_sql IS 'INSERT OR UPDATE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()';
COMMENT ON TRIGGER t_rif40_study_sql_checks_del ON t_rif40_study_sql IS 'DELETE trigger: calls rif40_trg_pkg.trigger_fct_t_rif40_study_sql_checks()';

\echo All table IUD checks built...
--
-- Eof
